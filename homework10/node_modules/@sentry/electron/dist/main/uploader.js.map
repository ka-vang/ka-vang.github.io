{"version":3,"file":"uploader.js","sourceRoot":"","sources":["../../src/main/uploader.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\nimport { basename, join } from 'path';\nimport { promisify } from 'util';\n\nimport { Dsn } from '@sentry/core';\nimport { SentryEvent, SentryResponse, Status } from '@sentry/types';\nimport { filterAsync } from '@sentry/utils/async';\nimport { mkdirp } from '@sentry/utils/fs';\nimport { Store } from '@sentry/utils/store';\nimport fetch from 'electron-fetch';\nimport FormData = require('form-data');\n\nconst readdir = promisify(fs.readdir);\nconst rename = promisify(fs.rename);\nconst stat = promisify(fs.stat);\nconst unlink = promisify(fs.unlink);\n\n/** Status code returned by Sentry to retry event submission later. */\nconst CODE_RETRY = 429;\n\n/** Maximum number of days to keep a minidump before deleting it. */\nconst MAX_AGE = 30;\n\n/** Maximum number of requests that we store/queue if something goes wrong. */\nconst MAX_REQUESTS_COUNT = 10;\n\n/** Supported types of Electron CrashReporters. */\ntype CrashReporterType = 'crashpad' | 'breakpad';\n\n/**\n * Payload for a minidump request comprising a persistent file system path and\n * event metadata.\n */\nexport interface MinidumpRequest {\n  /** Path to the minidump file. */\n  path: string;\n  /** Associated event data. */\n  event: SentryEvent;\n}\n\n/**\n * A service that discovers Minidump crash reports and uploads them to Sentry.\n */\nexport class MinidumpUploader {\n  /** The minidump ingestion endpoint URL. */\n  private readonly url: string;\n\n  /** The type of the Electron CrashReporter used to search for Minidumps. */\n  private readonly type: CrashReporterType;\n\n  /** List of minidumps that have been found already. */\n  private readonly knownPaths: string[];\n\n  /**\n   * Store to persist queued Minidumps beyond application crashes or lost\n   * internet connection.\n   */\n  private readonly queue: Store<MinidumpRequest[]> = new Store(this.cacheDirectory, 'queue', []);\n\n  /**\n   * Creates a new uploader instance.\n   *\n   * @param dsn The Sentry DSN.\n   * @param crashesDirectory The directory Electron stores crashes in.\n   * @param cacheDirectory A persistent directory to cache minidumps.\n   */\n  public constructor(dsn: Dsn, private readonly crashesDirectory: string, private readonly cacheDirectory: string) {\n    this.type = process.platform === 'darwin' ? 'crashpad' : 'breakpad';\n    this.knownPaths = [];\n\n    this.url = MinidumpUploader.minidumpUrlFromDsn(dsn);\n  }\n\n  /**\n   * Returns the minidump endpoint in Sentry\n   * @param dsn Dsn\n   */\n  public static minidumpUrlFromDsn(dsn: Dsn): string {\n    const { host, path, projectId, port, protocol, user } = dsn;\n    return `${protocol}://${host}${port !== '' ? `:${port}` : ''}${\n      path !== '' ? `/${path}` : ''\n    }/api/${projectId}/minidump?sentry_key=${user}`;\n  }\n\n  /**\n   * Uploads a minidump file to Sentry.\n   *\n   * @param path Absolute path to the minidump file.\n   * @param event Event data to attach to the minidump.\n   * @returns A promise that resolves when the upload is complete.\n   */\n  public async uploadMinidump(request: MinidumpRequest): Promise<SentryResponse> {\n    try {\n      const body = new FormData();\n      body.append('upload_file_minidump', fs.createReadStream(request.path));\n      body.append('sentry', JSON.stringify(request.event));\n      const response = await fetch(this.url, { method: 'POST', body });\n\n      // Too many requests, so we queue the event and send it later\n      if (response.status === CODE_RETRY) {\n        await this.queueMinidump(request);\n        return {\n          status: Status.RateLimit,\n        };\n      }\n\n      // We either succeeded or something went horribly wrong. Either way, we\n      // can remove the minidump file.\n      await unlink(request.path);\n\n      // Forget this minidump in all caches\n      this.queue.update(queued => queued.filter(stored => stored !== request));\n      this.knownPaths.splice(this.knownPaths.indexOf(request.path), 1);\n\n      // If we were successful, we can try to flush the remaining queue\n      if (response.ok) {\n        await this.flushQueue();\n      }\n\n      return {\n        status: Status.fromHttpCode(response.status),\n      };\n    } catch (err) {\n      // User's internet connection was down so we queue it as well\n      const error = err ? (err as { code: string }) : { code: '' };\n      if (error.code === 'ENOTFOUND') {\n        await this.queueMinidump(request);\n      }\n\n      return {\n        status: Status.Failed,\n      };\n    }\n  }\n\n  /**\n   * Searches for new, unknown minidump files in the crash directory.\n   * @returns A promise that resolves to absolute paths of those dumps.\n   */\n  public async getNewMinidumps(): Promise<string[]> {\n    const minidumps = this.type === 'crashpad' ? await this.scanCrashpadFolder() : await this.scanBreakpadFolder();\n\n    const oldestMs = new Date().getTime() - MAX_AGE * 24 * 3600 * 1000;\n    return filterAsync(minidumps, async path => {\n      // Skip files that we have seen before\n      if (this.knownPaths.indexOf(path) >= 0) {\n        return false;\n      }\n\n      // Lock this minidump until we have uploaded it or an error occurs and we\n      // remove it from the file system.\n      this.knownPaths.push(path);\n\n      // We do not want to upload minidumps that have been generated before a\n      // certain threshold. Those old files can be deleted immediately.\n      const stats = await stat(path);\n      if (stats.birthtimeMs < oldestMs) {\n        await unlink(path);\n        this.knownPaths.splice(this.knownPaths.indexOf(path), 1);\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /** Flushes locally cached minidumps from the queue. */\n  public async flushQueue(): Promise<void> {\n    await Promise.all(this.queue.get().map(async request => this.uploadMinidump(request)));\n  }\n\n  /** Scans the Crashpad directory structure for minidump files. */\n  private async scanCrashpadFolder(): Promise<string[]> {\n    // Crashpad moves minidump files directly into the completed/ folder. We can\n    // load them from there, upload to the server, and then delete it.\n    const dumpDirectory = join(this.crashesDirectory, 'completed');\n    const files = await readdir(dumpDirectory);\n    return files.filter(file => file.endsWith('.dmp')).map(file => join(dumpDirectory, file));\n  }\n\n  /** Scans the Breakpad directory structure for minidump files. */\n  private async scanBreakpadFolder(): Promise<string[]> {\n    // Breakpad stores all minidump files along with a metadata file directly in\n    // the crashes directory.\n    const files = await readdir(this.crashesDirectory);\n\n    // Remove all metadata files (asynchronously) and forget about them.\n    files\n      .filter(file => file.endsWith('.txt') && !file.endsWith('log.txt'))\n      .forEach(async file => unlink(join(this.crashesDirectory, file)));\n\n    return files.filter(file => file.endsWith('.dmp')).map(file => join(this.crashesDirectory, file));\n  }\n\n  /**\n   * Enqueues a minidump with event information for later upload.\n   * @param request The request containing a minidump and event info.\n   */\n  private async queueMinidump(request: MinidumpRequest): Promise<void> {\n    const filename = basename(request.path);\n\n    // Only enqueue if this minidump hasn't been enqueued before. Compare the\n    // filename instead of the full path, because we will move the file to a\n    // temporary location later on.\n    if (this.queue.get().some(req => basename(req.path) === filename)) {\n      return;\n    }\n\n    // Move the minidump file to a separate cache directory and enqueue it. Even\n    // if the Electron CrashReporter's cache directory gets wiped or changes,\n    // this will allow us to retry uploading the file later.\n    const queuePath = join(this.cacheDirectory, filename);\n    await mkdirp(this.cacheDirectory);\n    await rename(request.path, queuePath);\n\n    // Remove stale minidumps in case we go over limit. Note that we have to\n    // re-fetch the queue as it might have changed in the meanwhile. It is\n    // important to store the queue value again immediately to avoid phantom\n    // reads.\n    const requests = [...this.queue.get(), { ...request, path: queuePath }];\n    const stale = requests.splice(-MAX_REQUESTS_COUNT);\n    this.queue.set(requests);\n\n    await Promise.all(stale.map(async req => unlink(req.path)));\n  }\n}\n"]}